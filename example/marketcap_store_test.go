//go:build unix

// Code generated by mmapforge. DO NOT EDIT.

package example

import (
	"path/filepath"
	"sync"
	"testing"
)

func TestMarketCapStore_CreateClose(t *testing.T) {
	path := filepath.Join(t.TempDir(), "test.mmf")
	s, err := NewMarketCapStore(path)
	if err != nil {
		t.Fatalf("NewMarketCapStore: %v", err)
	}
	defer s.Close()

	if s.Len() != 0 {
		t.Fatalf("Len = %d, want 0", s.Len())
	}
}

func TestMarketCapStore_NewError(t *testing.T) {
	path := filepath.Join(t.TempDir(), "test.mmf")
	s, err := NewMarketCapStore(path)
	if err != nil {
		t.Fatalf("NewMarketCapStore: %v", err)
	}
	s.Close()

	if _, err := NewMarketCapStore(path); err == nil {
		t.Fatal("expected error creating store on existing path")
	}
}

func TestMarketCapStore_OpenError(t *testing.T) {
	path := filepath.Join(t.TempDir(), "nonexistent.mmf")
	if _, err := OpenMarketCapStore(path); err == nil {
		t.Fatal("expected error opening non-existent store")
	}
}

func TestMarketCapStore_FieldRoundTrip(t *testing.T) {
	path := filepath.Join(t.TempDir(), "test.mmf")
	s, err := NewMarketCapStore(path)
	if err != nil {
		t.Fatalf("NewMarketCapStore: %v", err)
	}
	defer s.Close()

	idx, err := s.Append()
	if err != nil {
		t.Fatalf("Append: %v", err)
	}

	if err := s.SetID(idx, uint64(18000000000000)); err != nil {
		t.Fatalf("SetID: %v", err)
	}
	{
		got, err := s.GetID(idx)
		if err != nil {
			t.Fatalf("GetID: %v", err)
		}
		if got != uint64(18000000000000) {
			t.Errorf("GetID = %v, want %v", got, uint64(18000000000000))
		}
	}

	if err := s.SetPrice(idx, float64(2.5)); err != nil {
		t.Fatalf("SetPrice: %v", err)
	}
	{
		got, err := s.GetPrice(idx)
		if err != nil {
			t.Fatalf("GetPrice: %v", err)
		}
		if got != float64(2.5) {
			t.Errorf("GetPrice = %v, want %v", got, float64(2.5))
		}
	}

	if err := s.SetVolume(idx, float64(2.5)); err != nil {
		t.Fatalf("SetVolume: %v", err)
	}
	{
		got, err := s.GetVolume(idx)
		if err != nil {
			t.Fatalf("GetVolume: %v", err)
		}
		if got != float64(2.5) {
			t.Errorf("GetVolume = %v, want %v", got, float64(2.5))
		}
	}

	if err := s.SetMarketCap(idx, float64(2.5)); err != nil {
		t.Fatalf("SetMarketCap: %v", err)
	}
	{
		got, err := s.GetMarketCap(idx)
		if err != nil {
			t.Fatalf("GetMarketCap: %v", err)
		}
		if got != float64(2.5) {
			t.Errorf("GetMarketCap = %v, want %v", got, float64(2.5))
		}
	}

	if err := s.SetStale(idx, true); err != nil {
		t.Fatalf("SetStale: %v", err)
	}
	{
		got, err := s.GetStale(idx)
		if err != nil {
			t.Fatalf("GetStale: %v", err)
		}
		if got != true {
			t.Errorf("GetStale = %v, want %v", got, true)
		}
	}
}

func TestMarketCapStore_GetOutOfBounds(t *testing.T) {
	path := filepath.Join(t.TempDir(), "test.mmf")
	s, err := NewMarketCapStore(path)
	if err != nil {
		t.Fatalf("NewMarketCapStore: %v", err)
	}
	defer s.Close()

	if _, err := s.GetID(0); err == nil {
		t.Errorf("GetID(0) on empty store: expected error")
	}

	if _, err := s.GetPrice(0); err == nil {
		t.Errorf("GetPrice(0) on empty store: expected error")
	}

	if _, err := s.GetVolume(0); err == nil {
		t.Errorf("GetVolume(0) on empty store: expected error")
	}

	if _, err := s.GetMarketCap(0); err == nil {
		t.Errorf("GetMarketCap(0) on empty store: expected error")
	}

	if _, err := s.GetStale(0); err == nil {
		t.Errorf("GetStale(0) on empty store: expected error")
	}
}

func TestMarketCapStore_SetOutOfBounds(t *testing.T) {
	path := filepath.Join(t.TempDir(), "test.mmf")
	s, err := NewMarketCapStore(path)
	if err != nil {
		t.Fatalf("NewMarketCapStore: %v", err)
	}
	defer s.Close()

	if err := s.SetID(0, uint64(18000000000000)); err == nil {
		t.Errorf("SetID(0) on empty store: expected error")
	}

	if err := s.SetPrice(0, float64(2.5)); err == nil {
		t.Errorf("SetPrice(0) on empty store: expected error")
	}

	if err := s.SetVolume(0, float64(2.5)); err == nil {
		t.Errorf("SetVolume(0) on empty store: expected error")
	}

	if err := s.SetMarketCap(0, float64(2.5)); err == nil {
		t.Errorf("SetMarketCap(0) on empty store: expected error")
	}

	if err := s.SetStale(0, true); err == nil {
		t.Errorf("SetStale(0) on empty store: expected error")
	}
}

func TestMarketCapStore_BulkGetSet(t *testing.T) {
	path := filepath.Join(t.TempDir(), "test.mmf")
	s, err := NewMarketCapStore(path)
	if err != nil {
		t.Fatalf("NewMarketCapStore: %v", err)
	}
	defer s.Close()

	idx, err := s.Append()
	if err != nil {
		t.Fatalf("Append: %v", err)
	}

	rec := &MarketCapRecord{
		ID:        uint64(18000000000000),
		Price:     float64(2.5),
		Volume:    float64(2.5),
		MarketCap: float64(2.5),
		Stale:     true,
	}
	if err := s.Set(idx, rec); err != nil {
		t.Fatalf("Set: %v", err)
	}

	got, err := s.Get(idx)
	if err != nil {
		t.Fatalf("Get: %v", err)
	}

	if got.ID != uint64(18000000000000) {
		t.Errorf("Get().ID = %v, want %v", got.ID, uint64(18000000000000))
	}

	if got.Price != float64(2.5) {
		t.Errorf("Get().Price = %v, want %v", got.Price, float64(2.5))
	}

	if got.Volume != float64(2.5) {
		t.Errorf("Get().Volume = %v, want %v", got.Volume, float64(2.5))
	}

	if got.MarketCap != float64(2.5) {
		t.Errorf("Get().MarketCap = %v, want %v", got.MarketCap, float64(2.5))
	}

	if got.Stale != true {
		t.Errorf("Get().Stale = %v, want %v", got.Stale, true)
	}
}

func TestMarketCapStore_BulkGetOutOfBounds(t *testing.T) {
	path := filepath.Join(t.TempDir(), "test.mmf")
	s, err := NewMarketCapStore(path)
	if err != nil {
		t.Fatalf("NewMarketCapStore: %v", err)
	}
	defer s.Close()

	if _, err := s.Get(0); err == nil {
		t.Error("Get(0) on empty store: expected error")
	}
}

func TestMarketCapStore_BulkSetOutOfBounds(t *testing.T) {
	path := filepath.Join(t.TempDir(), "test.mmf")
	s, err := NewMarketCapStore(path)
	if err != nil {
		t.Fatalf("NewMarketCapStore: %v", err)
	}
	defer s.Close()

	if err := s.Set(0, &MarketCapRecord{}); err == nil {
		t.Error("Set(0) on empty store: expected error")
	}
}

func TestMarketCapStore_MultipleRecords(t *testing.T) {
	path := filepath.Join(t.TempDir(), "test.mmf")
	s, err := NewMarketCapStore(path)
	if err != nil {
		t.Fatalf("NewMarketCapStore: %v", err)
	}
	defer s.Close()

	const n = 10
	for i := 0; i < n; i++ {
		if _, err := s.Append(); err != nil {
			t.Fatalf("Append(%d): %v", i, err)
		}
	}
	if s.Len() != n {
		t.Fatalf("Len = %d, want %d", s.Len(), n)
	}

	rec := &MarketCapRecord{
		ID:        uint64(18000000000000),
		Price:     float64(2.5),
		Volume:    float64(2.5),
		MarketCap: float64(2.5),
		Stale:     true,
	}
	for i := 0; i < n; i++ {
		if err := s.Set(i, rec); err != nil {
			t.Fatalf("Set(%d): %v", i, err)
		}
	}
	for i := 0; i < n; i++ {
		got, err := s.Get(i)
		if err != nil {
			t.Fatalf("Get(%d): %v", i, err)
		}
		if got.ID != uint64(18000000000000) {
			t.Errorf("Get(%d).ID = %v, want %v", i, got.ID, uint64(18000000000000))
		}
		if got.Price != float64(2.5) {
			t.Errorf("Get(%d).Price = %v, want %v", i, got.Price, float64(2.5))
		}
		if got.Volume != float64(2.5) {
			t.Errorf("Get(%d).Volume = %v, want %v", i, got.Volume, float64(2.5))
		}
		if got.MarketCap != float64(2.5) {
			t.Errorf("Get(%d).MarketCap = %v, want %v", i, got.MarketCap, float64(2.5))
		}
		if got.Stale != true {
			t.Errorf("Get(%d).Stale = %v, want %v", i, got.Stale, true)
		}
	}
}

func TestMarketCapStore_Persistence(t *testing.T) {
	path := filepath.Join(t.TempDir(), "test.mmf")

	{
		s, err := NewMarketCapStore(path)
		if err != nil {
			t.Fatalf("NewMarketCapStore: %v", err)
		}
		idx, err := s.Append()
		if err != nil {
			t.Fatalf("Append: %v", err)
		}
		rec := &MarketCapRecord{
			ID:        uint64(18000000000000),
			Price:     float64(2.5),
			Volume:    float64(2.5),
			MarketCap: float64(2.5),
			Stale:     true,
		}
		if err := s.Set(idx, rec); err != nil {
			t.Fatalf("Set: %v", err)
		}
		if err := s.Close(); err != nil {
			t.Fatalf("Close: %v", err)
		}
	}

	{
		s, err := OpenMarketCapStore(path)
		if err != nil {
			t.Fatalf("OpenMarketCapStore: %v", err)
		}
		defer s.Close()

		if s.Len() != 1 {
			t.Fatalf("Len = %d, want 1", s.Len())
		}

		got, err := s.Get(0)
		if err != nil {
			t.Fatalf("Get: %v", err)
		}

		if got.ID != uint64(18000000000000) {
			t.Errorf("Get().ID = %v, want %v", got.ID, uint64(18000000000000))
		}

		if got.Price != float64(2.5) {
			t.Errorf("Get().Price = %v, want %v", got.Price, float64(2.5))
		}

		if got.Volume != float64(2.5) {
			t.Errorf("Get().Volume = %v, want %v", got.Volume, float64(2.5))
		}

		if got.MarketCap != float64(2.5) {
			t.Errorf("Get().MarketCap = %v, want %v", got.MarketCap, float64(2.5))
		}

		if got.Stale != true {
			t.Errorf("Get().Stale = %v, want %v", got.Stale, true)
		}
	}
}

func TestMarketCapStore_ConcurrentReadWrite(t *testing.T) {
	path := filepath.Join(t.TempDir(), "test.mmf")
	s, err := NewMarketCapStore(path)
	if err != nil {
		t.Fatalf("NewMarketCapStore: %v", err)
	}
	defer s.Close()

	idx, err := s.Append()
	if err != nil {
		t.Fatalf("Append: %v", err)
	}

	const iterations = 2000
	var wg sync.WaitGroup
	done := make(chan struct{})

	wg.Add(1)
	go func() {
		defer wg.Done()
		rec := &MarketCapRecord{
			ID:        uint64(18000000000000),
			Price:     float64(2.5),
			Volume:    float64(2.5),
			MarketCap: float64(2.5),
			Stale:     true,
		}
		for {
			select {
			case <-done:
				return
			default:
			}
			_ = s.Set(idx, rec)
		}
	}()

	wg.Add(1)
	go func() {
		defer wg.Done()
		for i := 0; i < iterations; i++ {
			_, _ = s.Get(idx)
			_, _ = s.GetID(idx)
			_, _ = s.GetPrice(idx)
			_, _ = s.GetVolume(idx)
			_, _ = s.GetMarketCap(idx)
			_, _ = s.GetStale(idx)
		}
		close(done)
	}()

	wg.Wait()
}
